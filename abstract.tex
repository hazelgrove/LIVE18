% !TEX root = hazel-LIVE2018.tex

\begin{abstract}
Live programming environments aim to provide programmers (and sometimes audiences) 
with continuous feedback about a program's behavior as it is being edited. 
%
The problem is that programming languages typically assign meaning only 
 to programs that are \emph{complete}, i.e. syntactically well-formed and free
of type and binding errors. Consequently, the 
live feedback presented to the programmer suffers from temporal or perceptive gaps.

The \Hazel live functional programming environment addresses this ``{gap problem}'' from first principles: \Hazel assigns rich static and dynamic meaning to every incomplete program that the programmer can construct using \Hazel's language of structured edit actions. 
%
An incomplete program is represented, following recent work by \citet{popl-paper}, as an expression with \emph{holes}, where empty holes stand for missing expressions or types, and  non-empty holes 
operate as membranes around type inconsistencies. 
%
Rather than aborting when evaluation encounters any of these holes, as in
several existing systems, evaluation continues while recording the 
closure around each hole instance. 
These hole closures enable a \emph{fill-and-resume} operation that 
avoids the need to restart evaluation after edits that amount to hole filling. 
Furthermore, various editor services can report information from these hole closures 
to help the programmer decide how to fill the corresponding holes. 
We discuss two examples of these live, hole-driven editor services. 
First, we discuss \Hazel's \emph{live context inspector}, which allows the programmer to explore 
values from relevant hole closures when the cursor is on a hole in the program. 
Second, we discuss early work on \emph{live palettes}---user interfaces, which can themselves contain holes, that the programmer can directly manipulate to fill an expression hole. 
A live palette can use the closures associated with the hole being filled to provide 
specialized, concrete feedback about the dynamic consequences of the programmer's choices. 
Taken together, the result is a substantially more \emph{live and direct} typed functional programming experience.
\end{abstract}
