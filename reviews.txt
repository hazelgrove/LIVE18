Review #2A
===========================================================================

Overall merit
-------------
4. Accept

Reviewer expertise
------------------
4. Expert

Paper summary
-------------
This paper introduces live programming with holes, providing mechanisms for executions to tolerate holes, for the programmers to then fill them, and to allow for context inspection.

Comments for author
-------------------
The paper is well written enough and conveys the idea in an appropriate level of detail. However, the example used (quicksort) leaves way too much to the imagination in how the idea is actually useful. It does the job of describing how to use it, but it doesn't feel like it would actually be useful in using the idea for this example. Would someone really want to write quicksort like that? More to the point, in an idealized implementation of the idea, how do you see this improving programmer productivity? 

As a different approach, APX (https://www.youtube.com/watch?v=YLrdhFEAiqo) has as similar construct called "holey terms" that are terms as holes that provide (a) an anchor for scrubbing (similar to palettes here) and (b) emit default values based on the hole's inferred type context to allow the program to continue running in a reasonable state. For example, a holey vector term used as the position of a shape will have a default value that allows the shape to be displayed randomly on the screen somewhere (so not zero, and not something too high that the shape goes off screen). 

Idea could use a video to better grock the experience.


* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


Review #2B
===========================================================================

Overall merit
-------------
2. Weak reject

Reviewer expertise
------------------
2. Some familiarity

Paper summary
-------------
The paper describes a live programming environment for a functional language with holes.  A hole can be used in place of a missing expression or type, or can be used to "wrap" type errors.  Live programming requires a way to execute such programs.  One approach would be to treat the hole as an error, but this prevents a live environment from showing anything about the program past the point of the error.  The paper instead describes, and demonstrates through examples, dynamic semantics that allow evaluation to continue "around" a hole.  Furthermore, when the user eventually fills the hole in, evaluation can reuse the previous results, rather than restarting from scratch.

The paper also describes live palettes: GUIs that allow direct manipulation of hole fillings.  Palettes can themselves contain holes, and can be nested in each other.  Because they are associated with holes, palettes can also display information that depends on the surrounding code.

Comments for author
-------------------
(1) Much of the paper (almost everything related to the dynamic execution of programs with holes) seems very similar to:

Toward a Live Stepper for Typed Expressions with Holes
Cyrus Omar, Ian Voysey, Matthew A. Hammer

from the 2017 OOPSLA LIVE workshop.

The principle difference seems to be that, in the 2017 paper, Hazel programs were constructed via a structure editor, which prevented the programmer from writing ill typed programs. In this paper, programs are written in text, and holes are used to wrap type errors.  This allows execution to proceed both in and outside the area with the type error.  While this is a nice idea, it comprises a relatively small amount of paper.  Ideally this would be expanded, perhaps with a more involved example. At a minimum, the above paper should be cited, and the distinctions between that paper and this one should be clearly stated.

(2) The paper also describes implementing palettes (GUIs to manipulate code) for Hazel.  In Hazel, palettes are user definable, as opposed to other tools which offer a fixed set of palettes.  Data described in the palette can depend on data generated by the code, or by other palettes. This is a nice idea, which relies on Hazel's ability to execute code around holes.  Again, cutting down on duplication from the 2017 paper would allow this idea to be further explored.


* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


Review #2C
===========================================================================

Overall merit
-------------
4. Accept

Reviewer expertise
------------------
4. Expert

Paper summary
-------------
A programming system that allows "holes" -- missing or incomplete values or types. The holes can be have their contexts inspected, or be filled in interactively, thereby adding a bit of liveness to the programming environment.

Comments for author
-------------------
While not completely live programming, it does add some liveness to the programming environment by decoupling concrete values from the structure of the program, allowing the former to be provided on the fly, interactively. It allows computation to proceed even in the absence of a fully specified value, and gives the programmer tools for examining the context and filling in the concrete values without restarting the program. 

Very useful, well thought out and well presented. 

It's strange that there's no mention of Partial Evaluation, traditionally the field where this sort of thing lies, e.g. 

https://www.itu.dk/~sestoft/pebook/jonesgomardsestoft-letter.pdf

An innovative programming environment that uses partial evaluation to present a hole-like interface is:

http://web.media.mit.edu/~lieber/Your-Wish/02-Kahn.pdf

